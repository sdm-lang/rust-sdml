/*!
One-line description.

More detailed description, with

# Example

YYYYY

*/

use crate::error::Error;
use ansi_term::{Color, Style};
use std::io::Write;
use tree_sitter_highlight::HighlightConfiguration;
use tree_sitter_highlight::HighlightEvent;
use tree_sitter_highlight::Highlighter;
use tree_sitter_highlight::HtmlRenderer;

// ------------------------------------------------------------------------------------------------
// Public Macros
// ------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------
// Public Types
// ------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------
// Public Functions
// ------------------------------------------------------------------------------------------------

const HIGHLIGHT_NAMES: &[&str] = &[
    "comment",
    "constant.builtin",
    "error",
    "function.call",
    "keyword",
    "operator",
    "module",
    "module.definition",
    "number",
    "property",
    "punctuation.bracket",
    "string",
    "string.special",
    "type",
    "type.definition",
    "variable.field",
];

const HTML_HEADER: &str = r##"<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />

    <title>Formatted SDML</title>

    <link
      href="https://fonts.googleapis.com/css?family=Fira+Code:300,600|Fira+Sans:100,100i,200,200i,400,400i&display=swap"
      rel="stylesheet">

    <style>
    body {
      font-family: "Fira Sans",sans;
    }
    pre.sdml {
      font-family: "Fira Code",monospace;
      font-size: .9em;
      font-weight: 300;
      line-height: 1.4;
      padding: .6em;
      border: 1px solid #e1e4e5;
      white-space: pre;
    }
    pre.sdml code {
      font-family: "Fira Code",monospace;
    }
    pre.sdml code span.sdml-comment {
      color: #949494;
      font-style: italic;
    }
    pre.sdml code span.sdml-constant-builtin {
      color: #5f5f00;
    }
    pre.sdml code span.sdml-error {
      color: #ff0000;
    }
    pre.sdml code span.sdml-function-call {
      color: #005fd7;
    }
    pre.sdml code span.sdml-keyword {
      color: #878700;
    }
    pre.sdml code span.sdml-operator {
      color: #4e4e4e;
      font-weight: bold;
    }
    pre.sdml code span.sdml-module {
      color: #005faf;
    }
    pre.sdml code span.sdml-module-definition {
      color: #0000af;
    }
    pre.sdml code span.sdml-number {
      color: #5f5f00;
    }
    pre.sdml code span.sdml-property {
      color: #d70000;
    }
    pre.sdml code span.sdml-punctuation-bracket {
      color: #4e4e4e;
    }
    pre.sdml code span.sdml-string {
      color: #5faf00;
    }
    pre.sdml code span.sdml-string-special {
      color: #8700d7;
    }
    pre.sdml code span.sdml-type {
      color: #005fff;
    }
    pre.sdml code span.sdml-type-definition {
      color: #0000ff;
    }
    pre.sdml code span.sdml-variable-field {
      color: #5f87af;
    }
    </style>
  </head>

  <body>

    <header>
      <h1>Formatted SDML</h1>
    </header>

    <main>
"##;

const HTML_FOOTER: &str = r##"    </main>

    <footer>
      <p>Generated by sdml <a href="https://github.com/johnstonskj/rust-sdml">command-line tool</a>.</p>
    </footer>

  </body>
</html>
"##;

pub fn write_highlighted_as_ansi<S: AsRef<[u8]>, W: Write>(
    source: S,
    w: &mut W,
) -> Result<(), Error> {
    let (mut highlighter, config) = highlighter_init();

    let events = highlighter
        .highlight(&config, source.as_ref(), None, |_| None)
        .unwrap();

    highlight_as_ansi(&source, w, events)
}

pub fn write_highlighted_as_html<S: AsRef<[u8]>, W: Write>(
    source: S,
    w: &mut W,
    stand_alone: bool,
) -> Result<(), Error> {
    let (mut highlighter, config) = highlighter_init();

    let events = highlighter
        .highlight(&config, source.as_ref(), None, |_| None)
        .unwrap();

    highlight_as_html(&source, w, events, stand_alone)
}

// write_to_string!(to_highlighted_string, write_highlighted);
//
// write_to_file!(to_highlighted_file, write_highlighted);
//
// print_to_stdout!(print_highlighted, write_highlighted);

// ------------------------------------------------------------------------------------------------
// Private Macros
// ------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------
// Private Types
// ------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------
// Implementations
// ------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------
// Private Functions
// ------------------------------------------------------------------------------------------------

fn highlight_as_ansi<S: AsRef<[u8]>, W: Write>(
    source: S,
    w: &mut W,
    events: impl Iterator<Item = Result<HighlightEvent, tree_sitter_highlight::Error>>,
) -> Result<(), Error> {
    let styles: Vec<Style> = vec![
        Style::new().fg(Color::Fixed(248)).italic(),  // comment
        Style::new().fg(Color::Fixed(58)),            // constant.builtin
        Style::new().fg(Color::Fixed(9)).underline(), // error
        Style::new().fg(Color::Fixed(26)),            // function.call
        Style::new().fg(Color::Fixed(100)),           // keyword
        Style::new().fg(Color::Fixed(239)).bold(),    // operator
        Style::new().fg(Color::Fixed(25)),            // module
        Style::new().fg(Color::Fixed(19)),            // module.definition
        Style::new().fg(Color::Fixed(58)),            // number
        Style::new().fg(Color::Fixed(160)),           // property
        Style::new().fg(Color::Fixed(239)),           // punctuation.bracket
        Style::new().fg(Color::Fixed(70)),            // string
        Style::new().fg(Color::Fixed(92)),            // string.special
        Style::new().fg(Color::Fixed(27)),            // type
        Style::new().fg(Color::Fixed(21)),            // type.definition
        Style::new().fg(Color::Fixed(67)),            // variable.field
    ];

    highlight_as_ansi_inner(source, w, &styles, events)
}

fn highlight_as_ansi_inner<S: AsRef<[u8]>, W: Write>(
    source: S,
    w: &mut W,
    styles: &[Style],
    events: impl Iterator<Item = Result<HighlightEvent, tree_sitter_highlight::Error>>,
) -> Result<(), Error> {
    let source = source.as_ref();
    let mut style_stack = vec![Style::new()];

    for event in events {
        match event.unwrap() {
            HighlightEvent::HighlightStart(highlight) => {
                style_stack.push(styles[highlight.0]);
            }
            HighlightEvent::HighlightEnd => {
                style_stack.pop();
            }
            HighlightEvent::Source { start, end } => {
                style_stack
                    .last()
                    .unwrap()
                    .paint(&source[start..end])
                    .write_to(&mut std::io::stdout())?;
            }
        }
    }

    Ok(())
}

fn highlight_as_html<S: AsRef<[u8]>, W: Write>(
    source: S,
    w: &mut W,
    events: impl Iterator<Item = Result<HighlightEvent, tree_sitter_highlight::Error>>,
    stand_alone: bool,
) -> Result<(), Error> {
    let css_classes: Vec<String> = HIGHLIGHT_NAMES
        .iter()
        .map(|s| format!("class=\"sdml-{}\"", s.replace('.', "-")))
        .collect();

    if stand_alone {
        write!(w, "{}", HTML_HEADER)?;
    }

    highlight_as_html_inner(source, w, &css_classes, events, if stand_alone { "      " } else { "" })?;

    if stand_alone {
        write!(w, "{}", HTML_FOOTER)?;
    }

    Ok(())
 }

fn highlight_as_html_inner<S: AsRef<[u8]>, W: Write>(
    source: S,
    w: &mut W,
    css_classes: &[String],
    events: impl Iterator<Item = Result<HighlightEvent, tree_sitter_highlight::Error>>,
    prefix: &str,
) -> Result<(), Error> {
    let mut renderer = HtmlRenderer::new();
    renderer
        .render(events, source.as_ref(), &move |highlight| {
            css_classes[highlight.0].as_bytes()
        })
        .unwrap();

    writeln!(w, "{}<pre class=\"sdml\">", prefix)?;
    writeln!(w, "{}  <code>", prefix)?;
    for line in renderer.lines() {
        write!(w, "{}    {}", prefix, line)?;
    }
    writeln!(w, "{}  </code>", prefix)?;
    writeln!(w, "{}</pre>", prefix)?;

    Ok(())
}

fn highlighter_init() -> (Highlighter, HighlightConfiguration) {
    let highlighter = Highlighter::new();
    let mut config = HighlightConfiguration::new(
        tree_sitter_sdml::language(),
        tree_sitter_sdml::HIGHLIGHTS_QUERY,
        tree_sitter_sdml::INJECTIONS_QUERY,
        "",
    )
    .unwrap();
    config.configure(HIGHLIGHT_NAMES);

    (highlighter, config)
}

// ------------------------------------------------------------------------------------------------
// Modules
// ------------------------------------------------------------------------------------------------
